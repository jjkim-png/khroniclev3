// donna-indices.js
// shots[], getHolePar(hole), expectedPuttsFromM(m), expectedStrokesOffGreenFromM(m, lie)
// 를 주입받아 Donna 고유 지표 계산

export function makeDonnaIndices({ shots, getHolePar,
  expectedPuttsFromM, expectedStrokesOffGreenFromM }) {

  const laneVal = l => (l==='LF' ? -1 : l==='RF' ? +1 : 0);
  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const mean=arr=>arr.length?arr.reduce((a,b)=>a+b,0)/arr.length:0;

  const U = {
    LG:1,CG:1,RG:1,
    LF:0.6,CF:0.6,RF:0.6,
    LR:0.4,RR:0.4,
    LBK:0.2,RBK:0.2,
    LOB:0,ROB:0,HZ:0,
    TEE:0.5
  };

  function estThreePuttProb(m){
    const d=Math.max(0,Number(m||0));
    if(d<=2) return 0.01; if(d<=4) return 0.03; if(d<=6) return 0.06; if(d<=8) return 0.10;
    if(d<=10) return 0.15; if(d<=12) return 0.20; if(d<=15) return 0.26; if(d<=20) return 0.33;
    if(d<=25) return 0.40; if(d<=30) return 0.48; if(d<=40) return 0.55; return 0.60;
  }

  function estimateTwoOnPenaltyRisk(roundIds){
    const rset=new Set(roundIds);
    const twoOnShots = shots.filter(
      s=> rset.has(s.roundId) &&
          s.phase==='approach' &&
          s.two_on_try===true
    );
    const n=twoOnShots.length;
    const sev = twoOnShots.map(s=>Number(s.penalty||0));
    const freq = n? (sev.filter(x=>x>0).length / n) : 0.06;
    const avgSev = sev.length? mean(sev) : 1.3;
    return { p:freq, avg:avgSev };
  }

  function computeSAIForRounds(roundIds){
    const rset=new Set(roundIds);
    const risk=estimateTwoOnPenaltyRisk(roundIds);
    const window=[80,90,100,110];
    const arr=[];
    shots.forEach(s=>{
      if(!rset.has(s.roundId)) return;
      if(s.phase!=='approach') return;
      const par=getHolePar(s.hole);
      if(par!==5) return;
      const d=Number(s.distance_m||0); if(d<=0) return;

      const ego = expectedStrokesOffGreenFromM(d, s.lie) + (risk.p*risk.avg);
      let elay=Infinity;
      window.forEach(t=>{
        const e = 1 + expectedStrokesOffGreenFromM(t,'CF');
        if(e<elay) elay=e;
      });
      const chosen = (s.two_on_try===true)?ego:elay;
      arr.push(chosen - Math.min(ego,elay));
    });
    return {mean:mean(arr), n:arr.length};
  }

  function computeLIGForRounds(roundIds){
    const rset=new Set(roundIds); const arr=[];
    shots.forEach(s=>{
      if(!rset.has(s.roundId)) return;
      const next=shots.find(n=>
        n.roundId===s.roundId &&
        n.hole===s.hole &&
        n.sequence===s.sequence+1
      );
      if(!next) return;
      arr.push( (U[next.lie]??0) - (U[s.lie]??0) );
    });
    return {mean:mean(arr), n:arr.length};
  }

  function computeMQSForRounds(roundIds){
    const rset=new Set(roundIds); const arr=[];
    const alpha=0.05,beta=0.10,gamma=0.05; const rM=15;
    shots.forEach(s=>{
      if(!rset.has(s.roundId)) return;
      if(!s.on_green) return;
      if(s.rel_x_m==null || s.rel_y_m==null) return;
      const x=+s.rel_x_m, y=+s.rel_y_m;
      const r=Math.hypot(x,y);
      const P=1-Math.min(1, r/rM);
      const aimL=(s.aim==='LF'||s.aim==='LG'),
            aimR=(s.aim==='RF'||s.aim==='RG');
      const aimMismatch=(aimL&&x>0)||(aimR&&x<0);
      const mqs=P
        -(y<0?alpha:0)
        -(y>0?beta:0)
        -(aimMismatch?gamma:0);
      arr.push(mqs);
    });
    return {mean:mean(arr), n:arr.length};
  }

  function computeTTPForRounds(roundIds){
    const rset=new Set(roundIds); const arr=[];
    shots.forEach(s=>{
      if(!rset.has(s.roundId)) return;
      if(s.phase!=='tee') return;
      const t=1-Math.abs(laneVal(s.aim)-laneVal(s.lie))/2;
      arr.push(t);
    });
    return {mean:mean(arr), n:arr.length};
  }

  function computeTPIForRounds(roundIds){
    const rset=new Set(roundIds); const arr=[];
    for(let h=1;h<=18;h++){
      const putts=shots
        .filter(s=> rset.has(s.roundId) &&
                    s.hole===h &&
                    s.phase==='putt')
        .sort((a,b)=>a.sequence-b.sequence);
      if(!putts.length) continue;
      const pi3=estThreePuttProb(+putts[0].distance_m||0);
      arr.push( putts.length>=3 ? -pi3 : +pi3 );
    }
    return {mean:mean(arr), n:arr.length};
  }

  function computePDIForRounds(roundIds){
    const rset=new Set(roundIds); const arr=[];
    shots.forEach(s=>{
      if(!rset.has(s.roundId)) return;
      const pen=+s.penalty||0;
      if(!pen) return;
      const next=shots.find(n=>
        n.roundId===s.roundId &&
        n.hole===s.hole &&
        n.sequence===s.sequence+1
      );
      const nxtU = next? (U[next.lie]??0) : 0.6;
      const extra=Math.max(0, 0.6-nxtU);
      arr.push(pen+extra);
    });
    return {mean:mean(arr), n:arr.length};
  }

  function computeDGI(SAI,LIG,MQS,TTP,TPI,PDI){
    const SAI_s=clamp(-SAI/0.20,-2,2);
    const LIG_s=clamp(LIG/0.30,-2,2);
    const MQS_s=clamp(MQS/0.30,-2,2);
    const TTP_s=clamp((TTP-0.70)/0.15,-2,2);
    const TPI_s=clamp(TPI/0.20,-2,2);
    const PDI_s=clamp(-PDI/1.50,-2,2);
    const w={SAI:.15,LIG:.10,MQS:.10,TTP:.05,TPI:.10,PDI:.10},
          sw=w.SAI+w.LIG+w.MQS+w.TTP+w.TPI+w.PDI;
    return (w.SAI*SAI_s+w.LIG*LIG_s+w.MQS*MQS_s+w.TTP*TTP_s+w.TPI*TPI_s+w.PDI*PDI_s)/sw;
  }

  function computeAll(roundIds){
    const SAI=computeSAIForRounds(roundIds).mean;
    const LIG=computeLIGForRounds(roundIds).mean;
    const MQS=computeMQSForRounds(roundIds).mean;
    const TTP=computeTTPForRounds(roundIds).mean;
    const TPI=computeTPIForRounds(roundIds).mean;
    const PDI=computePDIForRounds(roundIds).mean;
    const DGI=computeDGI(SAI,LIG,MQS,TTP,TPI,PDI);
    return {SAI,LIG,MQS,TTP,TPI,PDI,DGI};
  }

  return { computeAll };
}
